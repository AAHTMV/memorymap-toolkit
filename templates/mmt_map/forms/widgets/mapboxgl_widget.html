<div id="admin_map" style="width:100%; height: 300px;"></div>

<textarea id="map_geom" class="required hidden" cols="150" rows="10" name="{{ name }}">{{ serialized }}</textarea>

<script>

// Get the name of the feature being edited so it can be filtered

const name = django.jQuery('#id_name').val();

{% if serialized|length > 0 %}

const geomJson = JSON.parse('{{ serialized|safe }}');
const mapCenter = turf.center(geomJson).geometry.coordinates;

{% else %}

const mapCenter = [{{ config.MAP_CENTER_LONGITUDE }}, {{ config.MAP_CENTER_LATITUDE}}];

{% endif %}

const geomType = '{{ geom_type }}';

const drawControlsConfig = {
	trash: true
}

switch(geomType) {
	case 'Point':
		drawControlsConfig.point = true;
		break;
	case 'MultiPolygon':	
		drawControlsConfig.polygon = true;
	case 'MultiLineString':
		drawControlsConfig.line_string = true;
}


const baseMapStyleUrl = '{{ config.BASE_MAP_STYLE_URL }}';
const baseMapStyleKey = '{{ config.MAPTILER_KEY }}';

const map = new mapboxgl.Map({
    container: 'admin_map',
    center: mapCenter,
    zoom: 16.5,
    minZoom: 14.5,
    maxZoom: 18.5,
    attributionControl: true,
    logoPosition: 'top-left',
    scrollZoom: true,
    dragPan: true,
});

var draw;

django.jQuery.get(baseMapStyleUrl, function(data) {

    let style = data;

    // If the default map style is being used, add the key to the sources and glyphs urls
    if ('Ordnance Survey Open Zoomstack' in style.sources) {
        style.sources['Ordnance Survey Open Zoomstack'].url = style.sources['Ordnance Survey Open Zoomstack'].url + baseMapStyleKey;
        style.glyphs = style.glyphs + baseMapStyleKey;
    }

    map.setStyle(style);

    draw = new MapboxDraw({
		displayControlsDefault: false,
		controls: drawControlsConfig
	});

	map.addControl(draw, 'top-right');

	// If geomJson exists, add the feature to the map

	try {
		draw.add(geomJson);
	} catch {
		// do nothing
	}


	map.on('draw.create', updateGeom);
	map.on('draw.delete', updateGeom);
	map.on('draw.update', updateGeom);
});



map.on('load', function() { 

    map.addSource('interactive', {
        type: 'vector',
        url: '/tiles/interactive.json'
    });

    map.addLayer({
        'id': 'points',
        'source': 'interactive',
        'source-layer': 'points',
        'type': 'circle',
        'paint': {
            'circle-color': '#c1c1c1',
            'circle-radius': ["interpolate", ["linear"], ["zoom"], 
                14, ['*', 6, ['get', 'weight']],
                19, ['*', 12, ['get', 'weight']]
            ],
            'circle-opacity': 0.7,
            'circle-stroke-width': 2,
            'circle-pitch-alignment': 'map',
            'circle-stroke-color': '#c1c1c1'
        },
        'filter': ['!=', ['get', 'name'], name]
    });

    map.addLayer({
        'id': 'polygons',
        'source': 'interactive',
        'source-layer': 'polygons',
        'type': 'fill',
        'paint': {
            'fill-color': '#c1c1c1',
            'fill-opacity': 0.7,
        },
        'filter': ['!=', ['get', 'name'], name]
    });

    map.addLayer({
        'id': 'polygon_outlines',
        'source': 'interactive',
        'source-layer': 'polygons',
        'type': 'line',
        'paint': {
            'line-color': '#c1c1c1',
            'line-width': ["interpolate", ["linear"], ["zoom"], 
                14, 1, 
                19, 4
            ],
            'line-opacity': ["interpolate", ["linear"], ["zoom"], 
                14, 0.3, 
                19, 1
            ]
        },
        'filter': ['!=', ['get', 'name'], name]
    });
    
});





function updateGeom(e) {
	let data = draw.getAll();
	// if there's a feature, add the json representation to the text area and the map
	if (data.features.length > 0) {
		// Only allow one feature to exist at a time. To add multi-polygons use GIS (the results will be better in any case).
		if (data.features.length > 1) {
			let id = data.features[0].id;
			data.features.shift();
			draw.delete(id);
		}

		let feature = data.features[0].geometry;

		// Convert the GeoJSON to the correct feature types to match what GeoDjango expects. Lines and polygons are saved as MultiPolygons and MultiLineString geometries to support multi-part buildings or roads which can be added via a GIS; however, adding this editing capacity to the django admin site would be non-trivial.
		switch(feature.type) {
			case 'Polygon':
				feature.type = 'MultiPolygon';
				feature.coordinates = [feature.coordinates];
				break;
			case 'LineString':
				feature.type = 'MultiLineString';
				feature.coordinates = [feature.coordinates];
		}
		
		document.getElementById('map_geom').value = JSON.stringify(data.features[0].geometry);
	} else {
		document.getElementById('map_geom').value = '';
	}
}


</script>